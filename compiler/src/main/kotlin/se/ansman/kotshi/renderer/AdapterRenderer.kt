package se.ansman.kotshi.renderer

import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.NameAllocator
import com.squareup.kotlinpoet.ParameterSpec
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.plusParameter
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.jvm.throws
import se.ansman.kotshi.Types
import se.ansman.kotshi.Types.Moshi.jsonReaderOptions
import se.ansman.kotshi.applyEachIndexed
import se.ansman.kotshi.applyIf
import se.ansman.kotshi.model.DataClassJsonAdapter
import se.ansman.kotshi.model.EnumJsonAdapter
import se.ansman.kotshi.model.GeneratableJsonAdapter
import se.ansman.kotshi.model.GeneratedAdapter
import se.ansman.kotshi.model.ObjectJsonAdapter
import se.ansman.kotshi.model.SealedClassJsonAdapter
import se.ansman.kotshi.nullable
import se.ansman.kotshi.withoutVariance

abstract class AdapterRenderer(private val adapter: GeneratableJsonAdapter) {
    private var isUsed = false
    protected val nameAllocator: NameAllocator = NameAllocator().apply {
        newName("moshi")
        newName("types")
        newName("value")
        newName("writer")
        newName("reader")
        newName("stringBuilder")
        newName("it")
    }

    fun render(typeSpecModifier: TypeSpec.Builder.() -> Unit = {}): GeneratedAdapter {
        check(!isUsed)
        isUsed = true
        val value = ParameterSpec.builder("value", adapter.targetType.nullable()).build()
        val writer = ParameterSpec.builder("writer", Types.Moshi.jsonWriter).build()
        val reader = ParameterSpec.builder("reader", Types.Moshi.jsonReader).build()
        val typeSpec = TypeSpec.classBuilder(adapter.adapterName)
            .addModifiers(KModifier.INTERNAL)
            .addAnnotation(Types.Kotshi.internalKotshiApi)
            .addTypeVariables(adapter.targetTypeVariables.map { it.withoutVariance() })
            .superclass(Types.Kotshi.namedJsonAdapter.plusParameter(adapter.targetType))
            .addSuperclassConstructorParameter(
                "%S",
                "KotshiJsonAdapter(${adapter.targetSimpleNames.joinToString(".")})"
            )
            .apply { renderSetup() }
            .addFunction(FunSpec.builder("toJson")
                .addModifiers(KModifier.OVERRIDE)
                .throws(Types.Java.ioException)
                .addParameter(writer)
                .addParameter(value)
                .apply { renderToJson(writer, value) }
                .build())
            .addFunction(FunSpec.builder("fromJson")
                .addModifiers(KModifier.OVERRIDE)
                .throws(Types.Java.ioException)
                .addParameter(reader)
                .returns(adapter.targetType.nullable())
                .apply { renderFromJson(reader) }
                .build())
            .apply(typeSpecModifier)
            .build()
        return GeneratedAdapter(
            adapter = adapter,
            fileSpec = FileSpec.builder(adapter.targetPackageName, adapter.adapterName)
                .addComment("Code generated by Kotshi. Do not edit.")
                .addType(typeSpec)
                .build()
        )
    }

    protected open fun TypeSpec.Builder.renderSetup() {}
    protected abstract fun FunSpec.Builder.renderFromJson(readerParameter: ParameterSpec)
    protected abstract fun FunSpec.Builder.renderToJson(writerParameter: ParameterSpec, valueParameter: ParameterSpec)

    protected fun jsonOptionsProperty(jsonNames: Collection<String>): PropertySpec {
        require(jsonNames.isNotEmpty())
        return PropertySpec.builder(nameAllocator.newName("options"), jsonReaderOptions, KModifier.PRIVATE)
            .initializer(
                CodeBlock.Builder()
                    .add("%T.of(«", jsonReaderOptions)
                    .applyIf(jsonNames.size > 1) { add("\n") }
                    .applyEachIndexed(jsonNames) { index, name ->
                        if (index > 0) {
                            add(",\n")
                        }
                        add("%S", name)
                    }
                    .applyIf(jsonNames.size > 1) { add("\n") }
                    .add("»)")
                    .build())
            .build()
    }
}

fun GeneratableJsonAdapter.createRenderer(): AdapterRenderer =
    when (this) {
        is DataClassJsonAdapter -> DataClassAdapterRenderer(this)
        is EnumJsonAdapter -> EnumAdapterRenderer(this)
        is ObjectJsonAdapter -> ObjectAdapterRenderer(this)
        is SealedClassJsonAdapter -> SealedClassAdapterRenderer(this)
    }