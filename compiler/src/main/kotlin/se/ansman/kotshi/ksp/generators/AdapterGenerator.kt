package se.ansman.kotshi.ksp.generators

import com.google.devtools.ksp.getAllSuperTypes
import com.google.devtools.ksp.isInternal
import com.google.devtools.ksp.isLocal
import com.google.devtools.ksp.isPublic
import com.google.devtools.ksp.processing.Resolver
import com.google.devtools.ksp.processing.SymbolProcessorEnvironment
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.google.devtools.ksp.symbol.Modifier
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.MemberName.Companion.member
import com.squareup.kotlinpoet.NameAllocator
import com.squareup.kotlinpoet.ParameterSpec
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.plusParameter
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.TypeVariableName
import com.squareup.kotlinpoet.asClassName
import com.squareup.moshi.JsonAdapter
import com.squareup.moshi.JsonDataException
import com.squareup.moshi.JsonReader
import com.squareup.moshi.JsonWriter
import com.squareup.moshi.Moshi
import se.ansman.kotshi.GeneratedAdapter
import se.ansman.kotshi.GlobalConfig
import se.ansman.kotshi.KotshiUtils
import se.ansman.kotshi.NamedJsonAdapter
import se.ansman.kotshi.Polymorphic
import se.ansman.kotshi.PolymorphicLabel
import se.ansman.kotshi.applyEachIndexed
import se.ansman.kotshi.applyIf
import se.ansman.kotshi.ksp.KspProcessingError
import se.ansman.kotshi.ksp.addOriginatingKSFile
import se.ansman.kotshi.ksp.getAnnotation
import se.ansman.kotshi.ksp.getValue
import se.ansman.kotshi.ksp.toClassName
import se.ansman.kotshi.ksp.toTypeName
import se.ansman.kotshi.ksp.writeTo
import se.ansman.kotshi.nullable
import java.io.IOException
import java.lang.reflect.Type

@Suppress("UnstableApiUsage")
abstract class AdapterGenerator(
    protected val environment: SymbolProcessorEnvironment,
    protected val resolver: Resolver,
    protected val element: KSClassDeclaration,
    protected val globalConfig: GlobalConfig,
) {
    protected val nameAllocator = NameAllocator().apply {
        newName("options")
        newName("value")
        newName("writer")
        newName("reader")
        newName("stringBuilder")
        newName("it")
    }

    protected val className = element.toClassName()

    protected val typeVariables = element.typeParameters.map { typeParameter ->
        TypeVariableName(
            typeParameter.name.getShortName(),
            typeParameter.bounds
                .map { it.resolve().toTypeName() }
                .toList(),
        )
    }

    protected val typeName = if (typeVariables.isEmpty()) {
        className
    } else {
        className.parameterizedBy(typeVariables)
    }

    protected val value = ParameterSpec.builder("value", typeName.nullable()).build()

    fun generateAdapter(): GeneratedAdapter {
        when {
            Modifier.INNER in element.modifiers ->
                throw KspProcessingError("@JsonSerializable can't be applied to inner classes", element)
            element.isLocal() ->
                throw KspProcessingError("@JsonSerializable can't be applied to local classes", element)
            !element.isPublic() && !element.isInternal() ->
                throw KspProcessingError("Classes annotated with @JsonSerializable must public or internal", element)
        }

        val adapterClassName =
            ClassName(className.packageName, "Kotshi${className.simpleNames.joinToString("_")}JsonAdapter")

        val typeSpec = TypeSpec.classBuilder(adapterClassName)
            .addModifiers(KModifier.INTERNAL)
            .addOriginatingKSFile(element.containingFile!!)
            // TODO
//            .maybeAddGeneratedAnnotation(elements, sourceVersion)
            .addTypeVariables(typeVariables)
            .superclass(namedJsonAdapter.plusParameter(typeName))
            .addSuperclassConstructorParameter("%S", "KotshiJsonAdapter(${className.simpleNames.joinToString(".")})")
            .apply { addMethods() }
            .build()

        FileSpec.builder(adapterClassName.packageName, adapterClassName.simpleName)
            .addComment("Code generated by Kotshi. Do not edit.")
            .addType(typeSpec)
            .build()
            .writeTo(environment.codeGenerator)

        return GeneratedAdapter(
            targetType = className,
            className = adapterClassName,
            typeVariables = typeVariables,
            requiresMoshi = typeSpec.primaryConstructor
                ?.parameters
                ?.contains(moshiParameter)
                ?: false,
            requiresTypes = typeSpec.primaryConstructor
                ?.parameters
                ?.contains(typesParameter)
                ?: false
        )
    }

    protected abstract fun TypeSpec.Builder.addMethods()

    protected fun TypeSpec.Builder.maybeAddCompanion(jsonNames: Collection<String>): TypeSpec.Builder =
        applyIf(jsonNames.isNotEmpty()) {
            addOptions(jsonNames)
        }

    protected fun TypeSpec.Builder.addOptions(jsonNames: Collection<String>): TypeSpec.Builder =
        addProperty(PropertySpec.builder("options", jsonReaderOptions, KModifier.PRIVATE)
            .initializer(CodeBlock.Builder()
                .add("%T.of(«", jsonReaderOptions)
                .applyIf(jsonNames.size > 1) { add("\n") }
                .applyEachIndexed(jsonNames) { index, name ->
                    if (index > 0) {
                        add(",\n")
                    }
                    add("%S", name)
                }
                .applyIf(jsonNames.size > 1) { add("\n") }
                .add("»)")
                .build())
            .build())


    protected fun getPolymorphicLabels(): Map<String, String> = element.getPolymorphicLabels()

    private fun KSClassDeclaration.getPolymorphicLabels(): Map<String, String> {
        val output = LinkedHashMap<String, String>()
        val isPolymorphic = getAnnotation<PolymorphicLabel>() != null

        for (type in getAllSuperTypes().map { it.declaration } + sequenceOf(this)) {
            if (type is KSClassDeclaration) {
                val labelKey = type.nearestPolymorpicLabelKey()
                    ?: continue
                output[labelKey] = type.getAnnotation<PolymorphicLabel>()?.getValue<String>("value")
                    ?: continue
            } else {
                throw KspProcessingError("Unknown super type ${type.javaClass}", type)
            }
        }
        if (isPolymorphic && output.isEmpty()) {
            throw KspProcessingError("Found no polymorphic labels", this)
        }
        return output
    }

    private fun KSClassDeclaration.nearestPolymorpicLabelKey(): String? {
        for (superType in getAllSuperTypes()/*.toList().reversed()*/) {
            superType.declaration.getAnnotation<Polymorphic>()
                ?.getValue<String>("labelKey")
                ?.let { return it }
        }
        return null
    }
}

val kotshiUtilsByteValue = KotshiUtils::class.member("byteValue")
val kotshiUtilsValue = KotshiUtils::class.member("value")
val kotshiUtilsNextFloat = KotshiUtils::class.member("nextFloat")
val kotshiUtilsNextByte = KotshiUtils::class.member("nextByte")
val kotshiUtilsNextShort = KotshiUtils::class.member("nextShort")
val kotshiUtilsNextChar = KotshiUtils::class.member("nextChar")
val kotshiUtilsAppendNullableError = KotshiUtils::class.member("appendNullableError")
val kotshiUtilsCreateJsonQualifierImplementation = KotshiUtils::class.member("createJsonQualifierImplementation")

val namedJsonAdapter = NamedJsonAdapter::class.java.asClassName()
val jsonAdapter = JsonAdapter::class.java.asClassName()
val jsonDataException = JsonDataException::class.java.asClassName()
val jsonReaderOptions = JsonReader.Options::class.java.asClassName()
val jsonReaderToken = JsonReader.Token::class.java.asClassName()
val ioException = IOException::class.java.asClassName()
val jsonWriter = JsonWriter::class.java.asClassName()
val jsonReader = JsonReader::class.java.asClassName()

val writerParameter = ParameterSpec.builder("writer", jsonWriter).build()
val readerParameter = ParameterSpec.builder("reader", jsonReader).build()
val moshiParameter = ParameterSpec.builder("moshi", Moshi::class.java).build()
val typesParameter = ParameterSpec.builder("types", Array::class.plusParameter(Type::class)).build()

